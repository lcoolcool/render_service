# 渲染服务系统架构设计

> 基于竞品分析的系统改进方案
> 版本: v2.0
> 更新日期: 2025-11-04

---

## 1. 设计原则

### 1.1 核心原则

✅ **渐进式升级** - 保持现有系统稳定，新功能独立模块化开发
✅ **向后兼容** - 现有 API 继续工作，新 API 逐步替代
✅ **Windows 优化** - 纯 Windows 环境，简化跨平台复杂度
✅ **API 优先** - 先完善后端接口，客户端可后续开发
✅ **易于扩展** - 模块化设计，便于未来增加功能

### 1.2 技术约束

- **部署环境**: 纯 Windows 环境
- **现有技术栈**: FastAPI + Celery + Tortoise ORM + SQLite + OSS
- **不破坏现有功能**: 当前渲染任务流程继续正常工作
- **暂不开发客户端**: 通过 API 或 Web 界面调用

---

## 2. 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        客户端层 (未来扩展)                      │
├─────────────────────────────────────────────────────────────┤
│  - Web 管理界面 (可选)                                         │
│  - Python SDK (可选)                                         │
│  - Maya 插件 (可选)                                          │
└─────────────────────────────────────────────────────────────┘
                            ↓ HTTP/HTTPS
┌─────────────────────────────────────────────────────────────┐
│                        API 网关层                             │
├─────────────────────────────────────────────────────────────┤
│  FastAPI (Uvicorn)                                          │
│  - 路由管理                                                   │
│  - 请求验证                                                   │
│  - 错误处理                                                   │
│  - 日志记录                                                   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                      业务逻辑层 (Services)                     │
├─────────────────────────────────────────────────────────────┤
│  ┌────────────────┐  ┌────────────────┐  ┌───────────────┐  │
│  │ 场景分析服务    │  │ 文件管理服务    │  │ 任务调度服务   │  │
│  │ (新增)         │  │ (扩展)         │  │ (扩展)        │  │
│  └────────────────┘  └────────────────┘  └───────────────┘  │
│  ┌────────────────┐  ┌────────────────┐  ┌───────────────┐  │
│  │ 渲染引擎服务    │  │ OSS 存储服务    │  │ 硬件分配服务   │  │
│  │ (现有)         │  │ (现有)         │  │ (新增)        │  │
│  └────────────────┘  └────────────────┘  └───────────────┘  │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                      任务队列层 (Celery)                       │
├─────────────────────────────────────────────────────────────┤
│  Redis Broker                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ high_priority│  │   default    │  │ low_priority │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│                                                              │
│  Celery Workers (--pool=solo)                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ 场景分析任务  │  │ 渲染任务      │  │ 文件处理任务  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据持久层                               │
├─────────────────────────────────────────────────────────────┤
│  SQLite (通过 Tortoise ORM)                                 │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐            │
│  │ 任务表      │  │ 帧表        │  │ 资产表      │            │
│  │ (扩展)     │  │ (现有)      │  │ (新增)      │            │
│  └────────────┘  └────────────┘  └────────────┘            │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐            │
│  │ 用户表      │  │ 硬件配置表  │  │ 日志表      │            │
│  │ (新增)     │  │ (新增)      │  │ (可选)      │            │
│  └────────────┘  └────────────┘  └────────────┘            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                      存储层                                   │
├─────────────────────────────────────────────────────────────┤
│  阿里云 OSS                                                  │
│  ┌────────────────────┐  ┌────────────────────┐            │
│  │ 场景文件存储        │  │ 渲染结果存储        │            │
│  │ (按 unionid 隔离)  │  │ (按 task_id 隔离)  │            │
│  └────────────────────┘  └────────────────────┘            │
│                                                              │
│  本地工作空间 (C:/workspace)                                 │
│  workspace/{unionid}/{task_id}/                             │
│    ├── source/         (OSS 下载的原始文件)                   │
│    ├── project/        (解压后的工程文件)                     │
│    └── renders/        (渲染输出)                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                      渲染引擎层                               │
├─────────────────────────────────────────────────────────────┤
│  ┌────────────────┐  ┌────────────────┐                     │
│  │ Maya + Arnold  │  │ Unreal Engine  │  ...               │
│  └────────────────┘  └────────────────┘                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 模块设计

### 3.1 现有模块 (保持不变)

#### app/api/tasks.py
- `POST /api/tasks/` - 创建渲染任务
- `GET /api/tasks/{id}/status` - 查询任务状态
- `POST /api/tasks/{id}/cancel` - 取消任务
- `POST /api/tasks/{id}/cleanup` - 清理工作空间

#### app/services/renderer.py
- `BaseRenderer` - 渲染器抽象基类
- `MayaRenderer` - Maya + Arnold 渲染器
- `UERenderer` - Unreal Engine 渲染器

#### app/services/oss_storage.py
- OSS 文件上传/下载
- 文件完整性校验 (当前无)

#### app/services/file_preparation.py
- 文件下载和解压
- 工作空间准备

---

### 3.2 新增模块

#### 3.2.1 场景分析服务

**文件**: `app/services/scene_analyzer.py`

**功能**:
- 解析 Maya 场景文件，提取渲染设置
- 列出所有依赖资产（贴图、插件、缓存等）
- 检测缺失文件
- 生成 `asset.json` 格式的分析结果

**核心方法**:

```python
class SceneAnalyzer:
    """Maya 场景分析器"""

    def analyze_maya_scene(self, scene_file: str) -> dict:
        """
        分析 Maya 场景文件

        Returns:
            {
                "scene_info": {
                    "renderer": "arnold",
                    "start": 1,
                    "end": 100,
                    "width": 1920,
                    "height": 1080,
                    ...
                },
                "asset": [
                    "C:/textures/wood.jpg",
                    ...
                ],
                "missing": [
                    {"file1": "C:/missing.jpg"},
                    ...
                ]
            }
        """

    def extract_render_settings(self) -> dict:
        """提取渲染设置"""

    def find_dependencies(self) -> List[str]:
        """查找所有依赖文件"""

    def check_missing_files(self, assets: List[str]) -> List[dict]:
        """检查缺失文件"""
```

**技术实现**:
- 使用 `mayapy.exe` (Maya Python 解释器)
- 或者使用 `maya.standalone` 模块
- 或者解析 `.ma` 文本文件 (MEL 格式)

**API 端点**:
```
POST /api/scene/analyse
Body: {
    "scene_file": "C:/Project/wolf.ma"  或 OSS 路径
}
Response: asset.json 格式
```

---

#### 3.2.2 文件哈希服务

**文件**: `app/services/file_hasher.py`

**功能**:
- 计算文件的 MD5 和 xxHash
- 用于文件去重和完整性校验

**核心方法**:

```python
class FileHasher:
    """文件哈希计算"""

    @staticmethod
    def compute_md5(file_path: str) -> str:
        """计算 MD5"""

    @staticmethod
    def compute_xxhash(file_path: str) -> str:
        """计算 xxHash (更快)"""

    @staticmethod
    def compute_all(file_path: str) -> dict:
        """
        同时计算两种哈希

        Returns:
            {
                "hash": "6e57efc1fb88700dfc4820e160348f07",
                "xxhash": "7021565326244519815"
            }
        """

    @staticmethod
    def verify_file(file_path: str, expected_hash: str) -> bool:
        """验证文件完整性"""
```

**集成点**:
- 上传到 OSS 前计算 hash
- 下载后验证 hash
- 增量上传时检查 hash 是否已存在

---

#### 3.2.3 硬件分配服务

**文件**: `app/services/hardware_allocator.py`

**功能**:
- 根据任务的硬件需求 (RAM, GPU) 分配合适的渲染节点
- 管理硬件配置表
- 负载均衡

**核心方法**:

```python
class HardwareAllocator:
    """硬件资源分配器"""

    async def allocate_node(self, task: RenderTask) -> str:
        """
        为任务分配渲染节点

        Args:
            task: 包含 ram, gpu_count, hardware_config_ids

        Returns:
            node_id: 分配的节点ID (当前可能就是本机)
        """

    async def get_available_configs(self) -> List[HardwareConfig]:
        """获取可用的硬件配置"""

    async def check_resource_availability(
        self,
        ram: int,
        gpu_count: int
    ) -> bool:
        """检查资源是否可用"""
```

**注意**:
- 当前系统可能只有单机，可以简化为"检查本机资源是否满足需求"
- 未来扩展到多节点时，实现负载均衡算法

---

#### 3.2.4 测试帧管理器

**文件**: `app/services/test_frame_manager.py`

**功能**:
- 管理测试帧的渲染流程
- 先渲染测试帧，验证通过后继续其他帧

**核心方法**:

```python
class TestFrameManager:
    """测试帧管理器"""

    async def render_test_frame(self, task: RenderTask) -> bool:
        """
        渲染测试帧

        Returns:
            True: 测试帧成功，可以继续
            False: 测试帧失败，应停止
        """

    async def should_stop_after_test(self, task: RenderTask) -> bool:
        """检查是否应在测试帧后停止"""

    async def get_test_frame_number(self, task: RenderTask) -> int:
        """获取测试帧号"""
```

**集成到现有渲染流程**:

```python
# app/celery_app/tasks.py

async def render_task(task_id: str):
    task = await RenderTask.get(id=task_id)

    # 1. 准备文件 (现有逻辑)
    await prepare_files(task)

    # 2. 检查是否有测试帧
    if task.test_frames:
        test_result = await test_frame_manager.render_test_frame(task)
        if not test_result and task.stop_after_test:
            await task.update(status=TaskStatus.FAILED)
            return

    # 3. 渲染所有帧 (现有逻辑)
    await render_all_frames(task)
```

---

### 3.3 扩展模块

#### 3.3.1 扩展 OSS 存储服务

**新增功能**:
- ✅ 文件上传前检查 hash 是否已存在 (增量上传)
- ✅ 下载后验证 hash
- ✅ 记录上传历史到 `assets` 表

**改动**:

```python
# app/services/oss_storage.py

class OSSStorage:
    # 现有方法保持不变

    async def upload_with_dedup(self, local_path: str, oss_path: str) -> dict:
        """
        增量上传: 先检查 hash 是否已存在

        Returns:
            {
                "uploaded": False,  # 是否实际上传
                "reason": "file_exists",  # 跳过原因
                "hash": "...",
                "asset_id": 123
            }
        """
        # 1. 计算 hash
        hashes = file_hasher.compute_all(local_path)

        # 2. 检查数据库是否已存在
        existing = await Asset.filter(file_hash=hashes["hash"]).first()
        if existing:
            return {
                "uploaded": False,
                "reason": "file_exists",
                "hash": hashes["hash"],
                "asset_id": existing.id
            }

        # 3. 上传到 OSS
        await self.upload(local_path, oss_path)

        # 4. 记录到 assets 表
        asset = await Asset.create(
            file_path=local_path,
            file_hash=hashes["hash"],
            file_xxhash=hashes["xxhash"],
            file_size=os.path.getsize(local_path),
            storage_path=oss_path
        )

        return {
            "uploaded": True,
            "hash": hashes["hash"],
            "asset_id": asset.id
        }
```

---

#### 3.3.2 扩展任务调度服务

**新增功能**:
- ✅ 根据硬件需求调度任务
- ✅ 支持任务暂停/恢复
- ✅ 测试帧优先级

**改动**:

```python
# app/api/tasks.py

async def create_task(task_data: dict):
    # 现有逻辑...

    # 新增: 硬件需求验证
    if task_data.get("ram") or task_data.get("gpu_count"):
        available = await hardware_allocator.check_resource_availability(
            ram=task_data.get("ram", 0),
            gpu_count=task_data.get("gpu_count", 0)
        )
        if not available:
            raise HTTPException(
                status_code=400,
                detail="硬件资源不足,无法满足任务需求"
            )

    # 新增: 分配硬件配置
    task.hardware_config_id = await hardware_allocator.allocate_node(task)
    await task.save()

    # 现有: 分发到 Celery 队列
    ...
```

---

## 4. 数据流程

### 4.1 场景分析流程 (新增)

```
[客户端] 选择 Maya 场景文件
   ↓
1️⃣ POST /api/scene/analyse
   Body: { "scene_file": "C:/Project/wolf.ma" }
   ↓
[API] 创建 Celery 任务: analyze_scene_task
   ↓
[Worker] 调用 SceneAnalyzer
   - 使用 mayapy.exe 解析场景
   - 提取渲染设置
   - 列出依赖资产
   - 检查缺失文件
   ↓
[Worker] 返回分析结果
   {
     "scene_info": {...},
     "asset": [...],
     "missing": [...]
   }
   ↓
[API] 保存到数据库 (可选: 缓存分析结果)
   ↓
[客户端] 显示分析结果
   - 渲染设置预览
   - 缺失文件列表 (红色标记)
   - 提示用户修复
```

---

### 4.2 增量上传流程 (新增)

```
[客户端] 准备上传文件列表
   ↓
1️⃣ 计算所有文件的 hash
   files = [
     {"local": "C:/tex/wood.jpg", "hash": "abc123"},
     {"local": "C:/tex/metal.jpg", "hash": "def456"},
   ]
   ↓
2️⃣ POST /api/files/check_hashes
   Body: { "hashes": ["abc123", "def456"] }
   ↓
[API] 查询数据库
   existing = SELECT file_hash FROM assets WHERE file_hash IN (...)
   ↓
[API] 返回需要上传的文件
   {
     "to_upload": ["def456"],  # 需要上传
     "exists": ["abc123"]      # 已存在,跳过
   }
   ↓
3️⃣ [客户端] 只上传 to_upload 的文件
   POST /api/files/upload (逐个上传)
   ↓
[API] 上传到 OSS + 记录到 assets 表
```

---

### 4.3 测试帧渲染流程 (新增)

```
[客户端] 创建任务时指定测试帧
   {
     "test_frames": "50",
     "stop_after_test": true,
     ...
   }
   ↓
1️⃣ POST /api/tasks/
   ↓
[API] 创建任务 + 分发到 Celery
   ↓
[Worker] 执行 render_task
   ↓
2️⃣ [Worker] 检查是否有测试帧
   if task.test_frames:
      先渲染测试帧
   ↓
3️⃣ [Worker] 渲染测试帧 (frame_number=50)
   ↓
   成功? → 继续
   失败? → 检查 stop_after_test
      ↓
      true → 停止任务,状态改为 FAILED
      false → 继续渲染其他帧
   ↓
4️⃣ [Worker] 渲染其他帧
   frames = [1, 2, ..., 49, 51, ..., 100]
   逐帧渲染
   ↓
5️⃣ [Worker] 任务完成
```

---

## 5. 技术选型

### 5.1 场景分析技术

| 方案 | 优点 | 缺点 | 推荐 |
|------|------|------|------|
| **mayapy.exe** | 官方工具,完整 API | 需要安装 Maya | ⭐⭐⭐⭐⭐ |
| **maya.standalone** | Python 集成方便 | 同样需要 Maya | ⭐⭐⭐⭐ |
| **解析 .ma 文件** | 不需要 Maya | 复杂,难以处理所有情况 | ⭐⭐ |
| **第三方库 (pymaya)** | 轻量级 | 功能有限 | ⭐⭐⭐ |

**推荐**: 使用 `mayapy.exe` 或 `maya.standalone`

**示例代码**:

```python
import subprocess
import json

def analyze_with_mayapy(scene_file: str) -> dict:
    """使用 mayapy.exe 分析场景"""

    # 准备分析脚本
    script = f"""
import maya.standalone
maya.standalone.initialize()
import maya.cmds as cmds
import json

cmds.file(r"{scene_file}", open=True, force=True)

result = {{
    "renderer": cmds.getAttr("defaultRenderGlobals.currentRenderer"),
    "start": cmds.getAttr("defaultRenderGlobals.startFrame"),
    "end": cmds.getAttr("defaultRenderGlobals.endFrame"),
    "width": cmds.getAttr("defaultResolution.width"),
    "height": cmds.getAttr("defaultResolution.height"),
}}

print(json.dumps(result))
    """

    # 执行 mayapy
    mayapy = "C:/Program Files/Autodesk/Maya2024/bin/mayapy.exe"
    result = subprocess.run(
        [mayapy, "-c", script],
        capture_output=True,
        text=True
    )

    return json.loads(result.stdout)
```

---

### 5.2 文件哈希库

| 库 | 速度 | 安装 | 推荐 |
|----|------|------|------|
| **hashlib (MD5)** | 中等 | 内置 | ⭐⭐⭐⭐⭐ |
| **xxhash** | 极快 | pip install xxhash | ⭐⭐⭐⭐⭐ |
| **blake2** | 快速 | 内置 (Python 3.6+) | ⭐⭐⭐⭐ |

**推荐**: `hashlib.md5` + `xxhash.xxh64`

**依赖安装**:
```bash
pip install xxhash
```

---

### 5.3 数据库选型

当前使用 **SQLite** + **Tortoise ORM**，建议保持不变。

**优点**:
- 简单易用，无需独立数据库服务
- Tortoise ORM 提供异步支持
- 适合中小规模任务

**未来扩展**:
- 如果任务量增大，可迁移到 **PostgreSQL** 或 **MySQL**
- Tortoise ORM 支持多种数据库，迁移成本低

---

## 6. 部署架构

### 6.1 单机部署 (当前)

```
Windows Server / Windows 10

┌──────────────────────────────────────┐
│  FastAPI (端口 8000)                  │
│  - 接收 HTTP 请求                     │
│  - 返回任务状态                        │
├──────────────────────────────────────┤
│  Celery Worker (--pool=solo)         │
│  - 监听 Redis 队列                    │
│  - 执行渲染任务                        │
│  - 执行场景分析任务                    │
├──────────────────────────────────────┤
│  Redis (端口 6379)                    │
│  - 消息队列                           │
│  - 任务状态缓存 (可选)                 │
├──────────────────────────────────────┤
│  SQLite (db.sqlite3)                  │
│  - 任务数据                           │
│  - 用户数据                           │
│  - 资产数据                           │
├──────────────────────────────────────┤
│  本地工作空间 (C:/workspace)           │
│  - 场景文件                           │
│  - 渲染结果                           │
├──────────────────────────────────────┤
│  Maya 2024 + Arnold                   │
│  - 渲染引擎                           │
└──────────────────────────────────────┘
        ↓ 网络
┌──────────────────────────────────────┐
│  阿里云 OSS                            │
│  - 场景文件存储                        │
│  - 渲染结果存储                        │
└──────────────────────────────────────┘
```

### 6.2 启动命令

```bash
# 1. 启动 Redis
redis-server.exe

# 2. 启动 Celery Worker
celery -A app.celery_app.celery worker --pool=solo --loglevel=info -Q high_priority,default,low_priority

# 3. 启动 FastAPI
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

---

## 7. 安全性考虑

### 7.1 文件安全

- ✅ 用户级文件隔离 (按 unionid)
- ✅ 任务级文件隔离 (按 task_id)
- ✅ 文件 hash 校验，防止篡改
- ⚠️ 需要添加: 用户认证和权限控制

### 7.2 API 安全

- ⚠️ 建议添加: JWT 认证
- ⚠️ 建议添加: API 访问速率限制
- ⚠️ 建议添加: HTTPS 支持

---

## 8. 性能优化

### 8.1 数据库优化

```sql
-- 任务查询优化
CREATE INDEX idx_tasks_user_status ON tasks(user_id, status, created_at DESC);
CREATE INDEX idx_tasks_priority ON tasks(status, priority DESC, created_at ASC);

-- 资产去重优化
CREATE INDEX idx_assets_hash ON assets(file_hash, file_xxhash);

-- 帧查询优化
CREATE INDEX idx_frames_task_status ON frames(task_id, status);
```

### 8.2 缓存策略

- 场景分析结果缓存 (Redis)
- 硬件配置缓存 (内存)
- OSS 文件元数据缓存

---

## 9. 监控和日志

### 9.1 日志记录

```python
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("app.log"),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger("render_service")

# 关键操作日志
logger.info(f"Task {task_id} created by user {user_id}")
logger.warning(f"Test frame {frame_num} failed for task {task_id}")
logger.error(f"Render failed: {error_message}")
```

### 9.2 监控指标

- 任务队列长度 (Redis)
- 任务成功率
- 平均渲染时间
- 文件上传/下载速度

---

## 10. 未来扩展

### 10.1 多节点渲染农场

```
┌──────────────┐
│ API Server   │
└──────────────┘
       ↓
┌──────────────┐
│ Redis        │
└──────────────┘
       ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ Worker Node 1│  │ Worker Node 2│  │ Worker Node N│
│ - Maya 2024  │  │ - Maya 2024  │  │ - Maya 2024  │
│ - 64GB RAM   │  │ - 128GB RAM  │  │ - 256GB RAM  │
│ - 2x GPU     │  │ - 4x GPU     │  │ - 8x GPU     │
└──────────────┘  └──────────────┘  └──────────────┘
```

### 10.2 Web 管理界面

- 任务提交界面
- 进度监控看板
- 文件管理器
- 用户管理

### 10.3 Maya 插件

- 在 Maya 内直接提交渲染任务
- 自动分析当前场景
- 一键上传到渲染农场

---

## 总结

本架构设计遵循以下原则:

✅ **保持简单** - 不过度设计,先实现核心功能
✅ **渐进式** - 在现有系统基础上逐步添加功能
✅ **模块化** - 新功能独立模块,易于测试和维护
✅ **可扩展** - 为未来的多节点、Web 界面预留接口

下一步: 查看 [数据库设计文档](./数据库设计文档.md) 和 [实现步骤](./实现步骤.md)
