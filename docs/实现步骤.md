# 实现步骤文档

> 渲染服务系统改进实施计划
> 版本: v2.0
> 预计周期: 4-6 周
> 更新日期: 2025-11-04

---

## 1. 总体规划

### 1.1 开发原则

✅ **小步快跑** - 每个阶段完成后立即测试和部署
✅ **独立模块** - 新功能不影响现有系统运行
✅ **及时反馈** - 每个功能完成后验证效果
✅ **文档先行** - 代码实现前先确定接口和数据结构

### 1.2 时间规划

| 阶段 | 功能 | 预计时间 | 优先级 |
|------|------|----------|--------|
| **P0** | 测试帧 + 文件校验 | 1 周 | ⭐⭐⭐⭐⭐ |
| **P1** | 场景分析 + 硬件匹配 | 2 周 | ⭐⭐⭐⭐ |
| **P2** | 增量上传 + 任务暂停 | 2 周 | ⭐⭐⭐ |
| **P3** | 完整场景分析 + 分块渲染 | 1 周 | ⭐⭐ |

**总计**: 4-6 周 (根据实际情况调整)

---

## 2. 阶段 P0: 核心基础功能 (第 1 周)

### 2.1 目标

实现最核心的功能,快速验证可行性:
- ✅ 测试帧机制 (先渲染指定帧验证)
- ✅ 文件完整性校验 (MD5 + xxHash)
- ✅ 基础数据库扩展

### 2.2 任务清单

#### 任务 1: 数据库迁移 - 添加测试帧字段

**文件**: `app/models/task.py`

**步骤**:

1. 安装 Aerich
   ```bash
   pip install aerich
   ```

2. 初始化 Aerich
   ```bash
   aerich init -t app.config.TORTOISE_ORM
   aerich init-db
   ```

3. 修改 `RenderTask` 模型,添加字段:
   ```python
   test_frames: Optional[str] = Field(None, max_length=100)
   stop_after_test: bool = Field(default=False)
   scene_file_hash: Optional[str] = Field(None, max_length=64)
   ```

4. 修改 `RenderFrame` 模型,添加字段:
   ```python
   is_test_frame: bool = Field(default=False)
   output_hash: Optional[str] = Field(None, max_length=64)
   render_time: Optional[int] = Field(None)
   ```

5. 生成迁移文件:
   ```bash
   aerich migrate --name "add_test_frame_fields"
   ```

6. 应用迁移:
   ```bash
   aerich upgrade
   ```

**验证**:
```python
# 测试创建任务
task = await RenderTask.create(
    unionid="test_user",
    oss_file_path="test.ma",
    render_engine=RenderEngine.MAYA,
    test_frames="50",
    stop_after_test=True
)
assert task.test_frames == "50"
print("✅ 测试帧字段添加成功")
```

**预计时间**: 2 小时

---

#### 任务 2: 实现文件哈希服务

**文件**: `app/services/file_hasher.py`

**步骤**:

1. 安装依赖:
   ```bash
   pip install xxhash
   ```

2. 创建 `FileHasher` 类:
   ```python
   import hashlib
   import xxhash
   from typing import Dict

   class FileHasher:
       """文件哈希计算服务"""

       @staticmethod
       def compute_md5(file_path: str) -> str:
           """计算 MD5"""
           md5 = hashlib.md5()
           with open(file_path, "rb") as f:
               while chunk := f.read(8192):
                   md5.update(chunk)
           return md5.hexdigest()

       @staticmethod
       def compute_xxhash(file_path: str) -> str:
           """计算 xxHash"""
           xxh = xxhash.xxh64()
           with open(file_path, "rb") as f:
               while chunk := f.read(8192):
                   xxh.update(chunk)
           return str(xxh.intdigest())

       @staticmethod
       def compute_all(file_path: str) -> Dict[str, str]:
           """同时计算 MD5 和 xxHash"""
           md5 = hashlib.md5()
           xxh = xxhash.xxh64()

           with open(file_path, "rb") as f:
               while chunk := f.read(8192):
                   md5.update(chunk)
                   xxh.update(chunk)

           return {
               "hash": md5.hexdigest(),
               "xxhash": str(xxh.intdigest())
           }

       @staticmethod
       def verify_file(file_path: str, expected_hash: str) -> bool:
           """验证文件完整性"""
           actual_hash = FileHasher.compute_md5(file_path)
           return actual_hash == expected_hash
   ```

3. 添加单元测试:
   ```python
   # tests/test_file_hasher.py
   import pytest
   from app.services.file_hasher import FileHasher

   def test_compute_md5(tmp_path):
       # 创建测试文件
       test_file = tmp_path / "test.txt"
       test_file.write_text("Hello, World!")

       # 计算 hash
       hash_value = FileHasher.compute_md5(str(test_file))
       assert hash_value == "65a8e27d8879283831b664bd8b7f0ad4"

   def test_verify_file(tmp_path):
       test_file = tmp_path / "test.txt"
       test_file.write_text("Hello, World!")

       assert FileHasher.verify_file(
           str(test_file),
           "65a8e27d8879283831b664bd8b7f0ad4"
       )
   ```

4. 运行测试:
   ```bash
   pytest tests/test_file_hasher.py -v
   ```

**验证**:
```python
hashes = FileHasher.compute_all("test.txt")
print(f"MD5: {hashes['hash']}")
print(f"xxHash: {hashes['xxhash']}")
print("✅ 文件哈希服务实现成功")
```

**预计时间**: 3 小时

---

#### 任务 3: 实现测试帧管理器

**文件**: `app/services/test_frame_manager.py`

**步骤**:

1. 创建 `TestFrameManager` 类:
   ```python
   from app.models.task import RenderTask
   from app.models.frame import RenderFrame, FrameStatus
   from typing import Optional

   class TestFrameManager:
       """测试帧管理器"""

       async def get_test_frame_number(self, task: RenderTask) -> Optional[int]:
           """获取测试帧号"""
           if not task.test_frames:
               return None

           # 支持多个测试帧: "10,20,30"
           frames = [int(f.strip()) for f in task.test_frames.split(",")]
           return frames[0]  # 暂时只支持第一个

       async def render_test_frame(self, task: RenderTask) -> bool:
           """
           渲染测试帧

           Returns:
               True: 测试帧成功
               False: 测试帧失败
           """
           test_frame_num = await self.get_test_frame_number(task)
           if test_frame_num is None:
               return True  # 没有测试帧,视为成功

           # 查找测试帧
           test_frame = await RenderFrame.filter(
               task_id=task.id,
               frame_number=test_frame_num
           ).first()

           if not test_frame:
               # 创建测试帧记录
               test_frame = await RenderFrame.create(
                   task_id=task.id,
                   frame_number=test_frame_num,
                   is_test_frame=True,
                   status=FrameStatus.PENDING
               )

           # 标记为测试帧
           test_frame.is_test_frame = True
           await test_frame.save()

           # 渲染测试帧 (调用现有渲染逻辑)
           from app.services.renderer import get_renderer

           renderer = get_renderer(task.render_engine)
           # ... 渲染逻辑 ...

           return test_frame.status == FrameStatus.COMPLETED

       async def should_stop_after_test(
           self,
           task: RenderTask,
           test_success: bool
       ) -> bool:
           """检查是否应在测试帧后停止"""
           if not task.stop_after_test:
               return False

           return not test_success  # 测试失败则停止
   ```

2. 添加单元测试:
   ```python
   # tests/test_test_frame_manager.py
   import pytest
   from app.services.test_frame_manager import TestFrameManager

   @pytest.mark.asyncio
   async def test_get_test_frame_number():
       task = await RenderTask.create(
           unionid="test",
           oss_file_path="test.ma",
           render_engine=RenderEngine.MAYA,
           test_frames="50"
       )

       manager = TestFrameManager()
       frame_num = await manager.get_test_frame_number(task)
       assert frame_num == 50
   ```

**预计时间**: 4 小时

---

#### 任务 4: 集成测试帧到渲染流程

**文件**: `app/celery_app/tasks.py`

**步骤**:

1. 修改 `render_task` 函数:
   ```python
   from app.services.test_frame_manager import TestFrameManager

   async def render_task_async(task_id: int):
       task = await RenderTask.get(id=task_id)
       test_frame_manager = TestFrameManager()

       try:
           # === 1. 准备文件 (现有逻辑) ===
           await prepare_files(task)

           # === 2. 渲染测试帧 (新增) ===
           if task.test_frames:
               logger.info(f"开始渲染测试帧: {task.test_frames}")
               test_success = await test_frame_manager.render_test_frame(task)

               # 检查是否需要停止
               should_stop = await test_frame_manager.should_stop_after_test(
                   task,
                   test_success
               )

               if should_stop:
                   logger.warning(f"测试帧失败,停止任务 {task.id}")
                   task.status = TaskStatus.FAILED
                   task.error_message = "测试帧渲染失败"
                   await task.save()
                   return

               logger.info(f"测试帧渲染成功,继续渲染其他帧")

           # === 3. 渲染所有帧 (现有逻辑) ===
           await render_all_frames(task)

       except Exception as e:
           logger.error(f"任务 {task.id} 失败: {e}")
           task.status = TaskStatus.FAILED
           task.error_message = str(e)
           await task.save()
   ```

2. 运行集成测试:
   ```bash
   # 创建测试任务
   curl -X POST http://localhost:8000/api/tasks/ \
     -H "Content-Type: application/json" \
     -d '{
       "unionid": "test_user",
       "oss_file_path": "test.ma",
       "render_engine": "maya",
       "total_frames": 10,
       "test_frames": "5",
       "stop_after_test": true
     }'

   # 观察日志,验证测试帧先渲染
   ```

**验证**:
- ✅ 测试帧先渲染
- ✅ 测试帧成功后继续渲染其他帧
- ✅ 测试帧失败时停止任务 (如果 stop_after_test=true)

**预计时间**: 4 小时

---

#### 任务 5: 扩展 OSS 服务添加文件校验

**文件**: `app/services/oss_storage.py`

**步骤**:

1. 添加上传前校验:
   ```python
   from app.services.file_hasher import FileHasher

   class OSSStorage:
       # ... 现有方法 ...

       async def upload_with_hash(
           self,
           local_path: str,
           oss_path: str,
           compute_hash: bool = True
       ) -> dict:
           """上传文件并返回 hash"""

           # 计算 hash
           if compute_hash:
               hashes = FileHasher.compute_all(local_path)
           else:
               hashes = {"hash": None, "xxhash": None}

           # 上传到 OSS
           await self.upload(local_path, oss_path)

           return {
               "oss_path": oss_path,
               "hash": hashes["hash"],
               "xxhash": hashes["xxhash"],
               "size": os.path.getsize(local_path)
           }

       async def download_and_verify(
           self,
           oss_path: str,
           local_path: str,
           expected_hash: Optional[str] = None
       ) -> bool:
           """下载文件并验证完整性"""

           # 下载文件
           await self.download(oss_path, local_path)

           # 验证 hash
           if expected_hash:
               is_valid = FileHasher.verify_file(local_path, expected_hash)
               if not is_valid:
                   logger.error(f"文件校验失败: {oss_path}")
                   os.remove(local_path)
                   raise ValueError(f"文件完整性校验失败: {oss_path}")

           return True
   ```

2. 更新文件准备服务使用新方法:
   ```python
   # app/services/file_preparation.py

   async def download_project_file(task: RenderTask):
       # 下载并验证
       await oss_storage.download_and_verify(
           task.oss_file_path,
           local_path,
           expected_hash=task.scene_file_hash  # 如果有的话
       )
   ```

**预计时间**: 3 小时

---

### 2.3 P0 阶段验收标准

- ✅ 数据库新增字段迁移成功
- ✅ 文件哈希计算正确 (通过单元测试)
- ✅ 测试帧机制工作正常 (先渲染测试帧,成功后继续)
- ✅ 测试帧失败时能正确停止任务
- ✅ 文件上传/下载带 hash 校验

**总预计时间**: 16 小时 (约 2 天)

---

## 3. 阶段 P1: 场景分析和硬件匹配 (第 2-3 周)

### 3.1 目标

- ✅ 实现基础场景分析 (提取渲染设置)
- ✅ 硬件配置管理
- ✅ 硬件需求匹配

### 3.2 任务清单

#### 任务 6: 数据库迁移 - 添加硬件和资产表

**步骤**:

1. 创建新模型:
   ```bash
   # app/models/hardware.py
   # app/models/user.py
   # app/models/asset.py
   # app/models/task_asset.py
   ```

2. 生成迁移:
   ```bash
   aerich migrate --name "add_hardware_and_asset_tables"
   aerich upgrade
   ```

3. 插入初始硬件配置:
   ```python
   # scripts/init_hardware_configs.py
   await HardwareConfig.bulk_create([
       HardwareConfig(
           id="basic",
           config_name="基础配置",
           ram=16,
           cpu_cores=8,
           gpu_count=0,
           price_per_hour=0.5
       ),
       HardwareConfig(
           id="standard",
           config_name="标准配置",
           ram=32,
           cpu_cores=16,
           gpu_count=0,
           price_per_hour=1.0
       ),
       HardwareConfig(
           id="high_performance",
           config_name="高性能配置",
           ram=64,
           cpu_cores=24,
           gpu_count=2,
           gpu_model="RTX 4090",
           price_per_hour=2.5
       ),
   ])
   ```

**预计时间**: 4 小时

---

#### 任务 7: 实现场景分析服务 (基础版)

**文件**: `app/services/scene_analyzer.py`

**步骤**:

1. 创建 `SceneAnalyzer` 类:
   ```python
   import subprocess
   import json
   from pathlib import Path
   from typing import Dict, List

   class SceneAnalyzer:
       """Maya 场景分析器"""

       def __init__(self, mayapy_path: str = None):
           self.mayapy_path = mayapy_path or self._find_mayapy()

       def _find_mayapy(self) -> str:
           """自动查找 mayapy.exe"""
           possible_paths = [
               "C:/Program Files/Autodesk/Maya2024/bin/mayapy.exe",
               "C:/Program Files/Autodesk/Maya2023/bin/mayapy.exe",
           ]
           for path in possible_paths:
               if Path(path).exists():
                   return path
           raise FileNotFoundError("未找到 mayapy.exe")

       def analyze_maya_scene(self, scene_file: str) -> dict:
           """
           分析 Maya 场景文件

           Returns:
               {
                   "scene_info": {...},
                   "assets": [...],
                   "missing": [...]
               }
           """
           # 准备分析脚本
           script = self._generate_analysis_script(scene_file)

           # 执行 mayapy
           result = subprocess.run(
               [self.mayapy_path, "-c", script],
               capture_output=True,
               text=True,
               timeout=300  # 5分钟超时
           )

           if result.returncode != 0:
               raise RuntimeError(f"场景分析失败: {result.stderr}")

           # 解析输出
           return json.loads(result.stdout)

       def _generate_analysis_script(self, scene_file: str) -> str:
           """生成 Maya Python 分析脚本"""
           return f'''
import maya.standalone
maya.standalone.initialize()
import maya.cmds as cmds
import json
import os

try:
    # 打开场景
    cmds.file(r"{scene_file}", open=True, force=True)

    # 提取渲染设置
    scene_info = {{
        "renderer": cmds.getAttr("defaultRenderGlobals.currentRenderer"),
        "start_frame": int(cmds.getAttr("defaultRenderGlobals.startFrame")),
        "end_frame": int(cmds.getAttr("defaultRenderGlobals.endFrame")),
        "by_frame": int(cmds.getAttr("defaultRenderGlobals.byFrameStep")),
        "width": int(cmds.getAttr("defaultResolution.width")),
        "height": int(cmds.getAttr("defaultResolution.height")),
        "image_format": cmds.getAttr("defaultRenderGlobals.imageFormat"),
    }}

    # 获取相机列表
    cameras = cmds.ls(type="camera")
    scene_info["all_cameras"] = cameras

    # 查找所有文件依赖
    file_nodes = cmds.ls(type="file")
    assets = []
    missing = []

    for node in file_nodes:
        file_path = cmds.getAttr(f"{{node}}.fileTextureName")
        exists = os.path.exists(file_path)

        assets.append({{
            "path": file_path,
            "type": "texture",
            "exists": exists
        }})

        if not exists:
            missing.append({{
                "node": node,
                "path": file_path,
                "reason": "file_not_found"
            }})

    # 输出 JSON
    result = {{
        "scene_info": scene_info,
        "assets": assets,
        "missing": missing
    }}

    print(json.dumps(result, ensure_ascii=False))

except Exception as e:
    error = {{"error": str(e)}}
    print(json.dumps(error))
    exit(1)
           '''
   ```

2. 添加单元测试:
   ```python
   # tests/test_scene_analyzer.py
   import pytest
   from app.services.scene_analyzer import SceneAnalyzer

   def test_analyze_maya_scene(tmp_path):
       # 准备测试场景文件 (简单的 .ma 文件)
       scene_file = tmp_path / "test.ma"
       scene_file.write_text("// Maya ASCII scene")

       analyzer = SceneAnalyzer()
       result = analyzer.analyze_maya_scene(str(scene_file))

       assert "scene_info" in result
       assert "assets" in result
   ```

**预计时间**: 8 小时

---

#### 任务 8: 实现硬件分配服务

**文件**: `app/services/hardware_allocator.py`

**步骤**:

1. 创建 `HardwareAllocator` 类:
   ```python
   from app.models.hardware import HardwareConfig
   from app.models.task import RenderTask
   from typing import Optional

   class HardwareAllocator:
       """硬件资源分配器"""

       async def allocate_node(self, task: RenderTask) -> Optional[str]:
           """为任务分配硬件配置"""

           # 如果用户指定了配置,验证是否可用
           if task.hardware_config_id:
               config = await HardwareConfig.get_or_none(
                   id=task.hardware_config_id,
                   is_available=True
               )
               if config:
                   return config.id

           # 否则根据需求自动匹配
           required_ram = task.ram or 16
           required_gpu = task.gpu_count or 0

           # 查找满足需求的最便宜配置
           suitable = await HardwareConfig.filter(
               ram__gte=required_ram,
               gpu_count__gte=required_gpu,
               is_available=True
           ).order_by("price_per_hour").first()

           if suitable:
               return suitable.id

           return None  # 无可用配置

       async def check_resource_availability(
           self,
           ram: int,
           gpu_count: int
       ) -> bool:
           """检查资源是否可用"""

           suitable = await HardwareConfig.filter(
               ram__gte=ram,
               gpu_count__gte=gpu_count,
               is_available=True
           ).exists()

           return suitable
   ```

2. 集成到任务创建:
   ```python
   # app/api/tasks.py

   from app.services.hardware_allocator import HardwareAllocator

   @router.post("/", status_code=201)
   async def create_task(task_data: CreateTaskRequest):
       hardware_allocator = HardwareAllocator()

       # 检查硬件资源是否可用
       if task_data.ram or task_data.gpu_count:
           available = await hardware_allocator.check_resource_availability(
               ram=task_data.ram or 0,
               gpu_count=task_data.gpu_count or 0
           )
           if not available:
               raise HTTPException(
                   status_code=400,
                   detail="硬件资源不足,无法满足任务需求"
               )

       # 创建任务
       task = await RenderTask.create(**task_data.dict())

       # 分配硬件配置
       config_id = await hardware_allocator.allocate_node(task)
       if config_id:
           task.hardware_config_id = config_id
           await task.save()

       # ... 分发到 Celery ...
   ```

**预计时间**: 6 小时

---

#### 任务 9: 添加场景分析 API

**文件**: `app/api/scene.py` (新文件)

**步骤**:

1. 创建路由:
   ```python
   from fastapi import APIRouter, HTTPException
   from pydantic import BaseModel
   from app.services.scene_analyzer import SceneAnalyzer

   router = APIRouter(prefix="/api/scene", tags=["场景分析"])

   class AnalyzeSceneRequest(BaseModel):
       scene_file: str
       unionid: str

   @router.post("/analyse")
   async def analyze_scene(request: AnalyzeSceneRequest):
       """分析场景文件"""

       try:
           analyzer = SceneAnalyzer()
           result = analyzer.analyze_maya_scene(request.scene_file)

           return {
               "code": 200,
               "message": "场景分析完成",
               "data": result
           }

       except Exception as e:
           raise HTTPException(
               status_code=500,
               detail=f"场景分析失败: {str(e)}"
           )
   ```

2. 注册路由:
   ```python
   # app/main.py
   from app.api import scene

   app.include_router(scene.router)
   ```

3. 测试 API:
   ```bash
   curl -X POST http://localhost:8000/api/scene/analyse \
     -H "Content-Type: application/json" \
     -d '{
       "scene_file": "C:/Project/test.ma",
       "unionid": "user123"
     }'
   ```

**预计时间**: 4 小时

---

### 3.3 P1 阶段验收标准

- ✅ 硬件配置表创建并插入初始数据
- ✅ 场景分析能正确提取渲染设置
- ✅ 硬件分配算法工作正常
- ✅ 场景分析 API 可用

**总预计时间**: 22 小时 (约 3 天)

---

## 4. 阶段 P2: 增量上传和任务控制 (第 4-5 周)

### 4.1 目标

- ✅ 实现增量上传 (基于 hash 去重)
- ✅ 任务暂停/恢复
- ✅ 资产管理

### 4.2 任务清单

#### 任务 10: 实现资产去重上传

**文件**: `app/api/files.py` (扩展)

**步骤**:

1. 添加文件 hash 检查接口:
   ```python
   @router.post("/check-hashes")
   async def check_hashes(request: CheckHashesRequest):
       """检查文件 hash 是否已存在"""

       existing_assets = await Asset.filter(
           file_hash__in=request.hashes
       ).all()

       existing_hashes = {a.file_hash: a for a in existing_assets}

       missing_hashes = [
           h for h in request.hashes
           if h not in existing_hashes
       ]

       return {
           "code": 200,
           "data": {
               "existing": [
                   {
                       "hash": asset.file_hash,
                       "asset_id": asset.id,
                       "storage_path": asset.storage_path
                   }
                   for asset in existing_assets
               ],
               "missing": missing_hashes
           }
       }
   ```

2. 添加增量上传接口:
   ```python
   @router.post("/upload")
   async def upload_file(
       file: UploadFile,
       hash: str = Form(...),
       file_type: str = Form("other"),
       unionid: str = Form(...)
   ):
       """上传文件 (带去重)"""

       # 检查是否已存在
       existing = await Asset.filter(file_hash=hash).first()
       if existing:
           # 增加引用计数
           existing.reference_count += 1
           await existing.save()

           return {
               "code": 200,
               "message": "文件已存在,跳过上传",
               "data": {
                   "asset_id": existing.id,
                   "file_hash": existing.file_hash,
                   "uploaded": False
               }
           }

       # 上传到 OSS
       oss_path = f"assets/{hash}"
       local_path = f"/tmp/{file.filename}"

       # 保存临时文件
       with open(local_path, "wb") as f:
           f.write(await file.read())

       # 上传到 OSS
       await oss_storage.upload(local_path, oss_path)

       # 创建资产记录
       asset = await Asset.create(
           file_path=file.filename,
           file_hash=hash,
           file_size=os.path.getsize(local_path),
           file_type=file_type,
           storage_path=oss_path,
           uploaded_by=unionid,
           reference_count=1
       )

       # 删除临时文件
       os.remove(local_path)

       return {
           "code": 201,
           "message": "文件上传成功",
           "data": {
               "asset_id": asset.id,
               "file_hash": asset.file_hash,
               "uploaded": True
           }
       }
   ```

**预计时间**: 6 小时

---

#### 任务 11: 实现任务暂停/恢复

**文件**: `app/api/tasks.py` (扩展)

**步骤**:

1. 扩展 TaskStatus 枚举:
   ```python
   class TaskStatus(str, Enum):
       QUEUED = "queued"
       PREPARING = "preparing"
       RENDERING = "rendering"
       PAUSED = "paused"        # 新增
       COMPLETED = "completed"
       FAILED = "failed"
       CANCELLED = "cancelled"
   ```

2. 添加暂停接口:
   ```python
   @router.post("/{task_id}/pause")
   async def pause_task(task_id: int):
       """暂停任务"""

       task = await RenderTask.get_or_none(id=task_id)
       if not task:
           raise HTTPException(status_code=404, detail="任务不存在")

       if task.status != TaskStatus.RENDERING:
           raise HTTPException(
               status_code=400,
               detail="只能暂停正在渲染的任务"
           )

       # 更新状态
       task.status = TaskStatus.PAUSED
       await task.save()

       # Celery 暂停 (可选,当前简化实现)
       # celery_app.control.revoke(task.celery_task_id, terminate=False)

       return {
           "code": 200,
           "message": "任务暂停成功",
           "data": {"id": task.id, "status": task.status}
       }
   ```

3. 添加恢复接口:
   ```python
   @router.post("/{task_id}/resume")
   async def resume_task(task_id: int):
       """恢复任务"""

       task = await RenderTask.get_or_none(id=task_id)
       if not task:
           raise HTTPException(status_code=404, detail="任务不存在")

       if task.status != TaskStatus.PAUSED:
           raise HTTPException(
               status_code=400,
               detail="只能恢复已暂停的任务"
           )

       # 更新状态
       task.status = TaskStatus.RENDERING
       await task.save()

       # 重新分发到 Celery
       # ... (重新提交未完成的帧)

       return {
           "code": 200,
           "message": "任务恢复成功",
           "data": {"id": task.id, "status": task.status}
       }
   ```

**预计时间**: 4 小时

---

### 4.3 P2 阶段验收标准

- ✅ 增量上传工作正常 (相同文件跳过上传)
- ✅ 任务可以暂停和恢复
- ✅ 资产引用计数正确

**总预计时间**: 10 小时 (约 1.5 天)

---

## 5. 技术难点和解决方案

### 5.1 难点 1: Maya 场景分析

**问题**: 如何在没有 Maya GUI 的情况下解析场景?

**解决方案**:
- 使用 `mayapy.exe` (Maya Python 解释器)
- 或者使用 `maya.standalone` 模块
- 通过 subprocess 调用,捕获 JSON 输出

**备选方案**:
- 解析 `.ma` 文本文件 (MEL 格式)
- 使用第三方库 (如 `pymel`)

---

### 5.2 难点 2: Windows 下的 Celery

**问题**: Windows 不支持 `fork`,Celery 必须使用 `--pool=solo`

**解决方案**:
- 启动 Worker 时始终使用 `--pool=solo`
- 避免使用依赖 fork 的功能

**注意事项**:
- `solo` 模式只有一个进程,无法并发
- 如需并发,启动多个 Worker 实例

---

### 5.3 难点 3: 大文件上传超时

**问题**: 大场景文件 (几百 MB) 上传可能超时

**解决方案**:
- 使用 OSS 分片上传 (oss2 SDK 支持)
- 设置合理的超时时间
- 前端显示上传进度

```python
# 分片上传示例
from oss2 import resumable_upload

oss2.resumable_upload(
    bucket,
    oss_path,
    local_path,
    multipart_threshold=100*1024*1024,  # 100MB 以上使用分片
    part_size=10*1024*1024,              # 每片 10MB
    num_threads=4                         # 4 个线程并发上传
)
```

---

## 6. 测试策略

### 6.1 单元测试

使用 `pytest` 测试核心逻辑:

```bash
# 测试文件哈希
pytest tests/test_file_hasher.py -v

# 测试场景分析
pytest tests/test_scene_analyzer.py -v

# 测试硬件分配
pytest tests/test_hardware_allocator.py -v
```

### 6.2 集成测试

测试完整流程:

```python
# tests/test_integration.py

@pytest.mark.asyncio
async def test_full_workflow():
    # 1. 创建任务 (带测试帧)
    response = client.post("/api/tasks/", json={
        "unionid": "test_user",
        "oss_file_path": "test.ma",
        "render_engine": "maya",
        "total_frames": 10,
        "test_frames": "5",
        "stop_after_test": True
    })
    assert response.status_code == 201
    task_id = response.json()["data"]["id"]

    # 2. 等待测试帧完成
    await asyncio.sleep(60)

    # 3. 检查状态
    response = client.get(f"/api/tasks/{task_id}/status")
    data = response.json()["data"]
    assert data["status"] in ["rendering", "completed"]

    # 4. 检查测试帧
    test_frame = await RenderFrame.filter(
        task_id=task_id,
        is_test_frame=True
    ).first()
    assert test_frame is not None
    assert test_frame.status == "completed"
```

### 6.3 性能测试

测试大规模任务:

```python
# 创建 100 个帧的任务,测试并发处理能力
for i in range(10):
    client.post("/api/tasks/", json={
        "unionid": f"user_{i}",
        "oss_file_path": "test.ma",
        "total_frames": 100
    })

# 监控 CPU、内存、磁盘使用率
```

---

## 7. 部署和上线

### 7.1 部署检查清单

- [ ] 数据库迁移已完成
- [ ] 环境变量配置正确
- [ ] Redis 服务运行正常
- [ ] OSS 连接测试通过
- [ ] Maya 可执行文件路径正确
- [ ] Celery Worker 启动正常
- [ ] API 健康检查通过

### 7.2 启动命令

```bash
# 1. 启动 Redis
redis-server.exe

# 2. 数据库迁移
aerich upgrade

# 3. 启动 Celery Worker
celery -A app.celery_app.celery worker --pool=solo --loglevel=info -Q high_priority,default,low_priority

# 4. 启动 FastAPI
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

---

## 8. 总结

### 8.1 时间规划总结

| 阶段 | 任务数 | 预计时间 | 关键功能 |
|------|--------|----------|----------|
| P0 | 5 | 16h (2天) | 测试帧 + 文件校验 |
| P1 | 4 | 22h (3天) | 场景分析 + 硬件匹配 |
| P2 | 2 | 10h (1.5天) | 增量上传 + 任务控制 |
| **总计** | **11** | **48h (6.5天)** | - |

**实际预留**: 加上测试和调试,预计 **2-3 周**完成全部功能。

### 8.2 优先级建议

1. **P0 必须做**: 测试帧机制 (验证场景正确性)
2. **P1 推荐做**: 场景分析 (提升用户体验)
3. **P2 可选做**: 增量上传 (节省带宽成本)

### 8.3 下一步

1. 与团队确认优先级
2. 准备开发环境 (安装 Maya, mayapy)
3. 从 P0 阶段开始实施
4. 每个阶段完成后进行验收测试

---

## 附录

### A. 依赖安装

```bash
# 新增依赖
pip install xxhash        # 文件哈希
pip install aerich        # 数据库迁移
```

### B. 开发环境要求

- Python 3.9+
- Maya 2024 (或其他版本)
- Redis 6.0+
- SQLite 3

### C. 相关文档

- [竞品分析报告](./竞品分析报告.md)
- [系统架构设计](./系统架构设计.md)
- [数据库设计文档](./数据库设计文档.md)
- [API接口设计](./API接口设计.md)
